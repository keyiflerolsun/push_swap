<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Push Swap Visualizer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            text-rendering: optimizeLegibility;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e1e1e 0%, #2d2d2d 100%);
            color: #ffffff;
            min-height: 100vh;
            padding: 15px;
            transform: translateZ(0);
            -webkit-transform: translateZ(0);
            backface-visibility: hidden;
            -webkit-backface-visibility: hidden;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 20px;
        }

        .header h1 {
            font-size: 2.2em;
            margin-bottom: 8px;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .controls {
            display: none;
        }

        .main-controls {
            display: grid;
            grid-template-columns: 2fr 1fr 1fr;
            gap: 20px;
            margin-bottom: 15px;
            align-items: stretch;
        }

        .input-section {
            display: flex;
            flex-direction: column;
            gap: 15px;
            height: 100%;
        }

        .button-section {
            display: flex;
            flex-direction: column;
            gap: 12px;
            align-items: stretch;
            justify-content: center;
            height: 100%;
            padding: 0 10px;
        }

        .controls-section {
            display: flex;
            flex-direction: column;
            gap: 12px;
            justify-content: center;
            height: 100%;
        }

        .control-buttons {
            display: flex;
            gap: 6px;
            justify-content: center;
            align-items: center;
        }

        .btn-play {
            background: linear-gradient(45deg, #28a745, #20c997);
            color: white;
            padding: 8px 12px;
            border: none;
            border-radius: 6px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 40px;
            font-weight: bold;
        }

        .btn-play:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(40, 167, 69, 0.4);
        }

        .btn-play.paused {
            background: linear-gradient(45deg, #dc3545, #c82333);
        }

        .btn-play.paused:hover {
            box-shadow: 0 4px 12px rgba(220, 53, 69, 0.4);
        }

        .btn-restart {
            background: linear-gradient(45deg, #17a2b8, #138496);
            color: white;
            padding: 6px 10px;
            border: none;
            border-radius: 5px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 35px;
            display: none;
        }

        .btn-restart:hover {
            transform: translateY(-1px);
            box-shadow: 0 3px 10px rgba(23, 162, 184, 0.4);
        }

        .btn-restart.visible {
            display: block;
        }

        .control-panel {
            background: rgba(45, 45, 45, 0.8);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .control-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 15px;
            margin-bottom: 12px;
        }

        .control-row:last-child {
            margin-bottom: 0;
        }

        .input-group {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .input-group label {
            font-size: 0.85em;
            color: #b0b0b0;
        }

        .input-group span {
            font-size: 0.85em;
            color: #4ecdc4;
        }

        textarea {
            padding: 8px 12px;
            border: 2px solid #444;
            border-radius: 6px;
            background: #2d2d2d;
            color: #fff;
            font-size: 14px;
            font-family: monospace;
            transition: all 0.3s ease;
            resize: vertical;
            min-height: 40px;
            line-height: 1.4;
            overflow-y: auto;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        textarea:focus {
            outline: none;
            border-color: #4ecdc4;
            box-shadow: 0 0 10px rgba(78, 205, 196, 0.3);
        }

        textarea:read-only {
            background: #1a1a1a;
            color: #b0b0b0;
            border-color: #333;
            cursor: default;
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none; /* IE and Edge */
        }

        textarea:read-only::-webkit-scrollbar {
            display: none; /* Chrome, Safari, Opera */
        }

        textarea:read-only:focus {
            border-color: #333;
            box-shadow: none;
        }

        .progress-bar {
            background: rgba(45, 45, 45, 0.8);
            border-radius: 12px;
            padding: 15px;
            margin: 20px 0;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .progress-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .progress-fill {
            height: 6px;
            background: linear-gradient(45deg, #4ecdc4, #44a08d);
            border-radius: 3px;
            transition: width 0.3s ease;
        }

        .progress-track {
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            overflow: hidden;
        }

        input[type="text"], input[type="range"] {
            padding: 8px 12px;
            border: 2px solid #444;
            border-radius: 6px;
            background: #2d2d2d;
            color: #fff;
            font-size: 14px;
            transition: all 0.3s ease;
            min-width: 200px;
        }

        input[type="range"] {
            min-width: 150px;
            padding: 4px;
        }

        input[type="text"]:focus, input[type="range"]:focus {
            outline: none;
            border-color: #4ecdc4;
            box-shadow: 0 0 10px rgba(78, 205, 196, 0.3);
        }

        button {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn-action {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            padding: 12px 20px;
            border: none;
            border-radius: 10px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
            box-shadow: 0 4px 15px rgba(16, 185, 129, 0.3);
            transform: translateZ(0);
            -webkit-transform: translateZ(0);
            backface-visibility: hidden;
            -webkit-backface-visibility: hidden;
        }

        .btn-action:hover {
            transform: translateY(-2px) translateZ(0);
            box-shadow: 0 8px 25px rgba(16, 185, 129, 0.4);
            background: linear-gradient(135deg, #059669 0%, #047857 100%);
        }

        .btn-reset {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
            color: white;
            padding: 10px 16px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 6px;
            box-shadow: 0 3px 10px rgba(239, 68, 68, 0.3);
            transform: translateZ(0);
            -webkit-transform: translateZ(0);
            backface-visibility: hidden;
            -webkit-backface-visibility: hidden;
        }

        .btn-reset:hover {
            transform: translateY(-2px) translateZ(0);
            box-shadow: 0 6px 20px rgba(239, 68, 68, 0.4);
            background: linear-gradient(135deg, #dc2626 0%, #b91c1c 100%);
        }

        .btn-small {
            background: linear-gradient(45deg, #6c757d, #495057);
            color: white;
            padding: 6px 10px;
            border: none;
            border-radius: 5px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 35px;
        }

        .btn-small:hover {
            transform: translateY(-1px);
            box-shadow: 0 3px 10px rgba(108, 117, 125, 0.4);
        }

        .icon {
            font-size: 1.1em;
        }

        .progress-bar {
            background: rgba(45, 45, 45, 0.8);
            border-radius: 8px;
            padding: 12px;
            margin: 15px 0;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .progress-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            font-size: 0.9em;
        }

        .progress-fill {
            height: 4px;
            background: linear-gradient(45deg, #4ecdc4, #44a08d);
            border-radius: 2px;
            transition: width 0.3s ease;
        }

        .progress-track {
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            overflow: hidden;
        }

        .stacks-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
            margin-bottom: 20px;
            transform: translateZ(0);
            -webkit-transform: translateZ(0);
            backface-visibility: hidden;
            -webkit-backface-visibility: hidden;
            will-change: contents;
        }

        .stack-wrapper {
            background: rgba(45, 45, 45, 0.8);
            border-radius: 8px;
            padding: 15px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .stack-label {
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 12px;
            text-align: center;
            color: #4ecdc4;
        }

        .stack {
            display: flex;
            flex-direction: row;
            gap: 1px;
            min-height: 150px;
            max-height: 300px;
            padding: 12px;
            background: rgba(30, 30, 30, 0.8);
            border-radius: 6px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            overflow: hidden;
            align-items: flex-end;
            justify-content: flex-start;
            width: 100%;
        }

        .stack.empty {
            justify-content: center;
            align-items: center;
            color: #666;
            font-style: italic;
        }

        .element {
            width: 2px;
            min-width: 1px;
            max-width: 6px;
            background: #4ecdc4;
            border-radius: 1px 1px 0 0;
            transition: all 0.3s ease;
            position: relative;
            flex-shrink: 0;
            transform: translateZ(0);
            -webkit-transform: translateZ(0);
            backface-visibility: hidden;
            -webkit-backface-visibility: hidden;
            perspective: 1000px;
            -webkit-perspective: 1000px;
            will-change: transform, box-shadow;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }

        .element:hover {
            transform: translateZ(0) scaleX(2) scaleY(1.1);
            box-shadow: 0 0 10px rgba(78, 205, 196, 0.6);
            z-index: 10;
            backface-visibility: hidden;
            -webkit-backface-visibility: hidden;
        }

        .element.highlighted {
            animation: glow 1s infinite;
            box-shadow: 0 0 10px rgba(255, 255, 0, 0.8);
            transform: translateZ(0);
            -webkit-transform: translateZ(0);
            backface-visibility: hidden;
            -webkit-backface-visibility: hidden;
        }

        @keyframes glow {
            0% { 
                box-shadow: 0 0 5px rgba(255, 255, 0, 0.8);
                transform: translateZ(0);
            }
            50% { 
                box-shadow: 0 0 20px rgba(255, 255, 0, 1);
                transform: translateZ(0);
            }
            100% { 
                box-shadow: 0 0 5px rgba(255, 255, 0, 0.8);
                transform: translateZ(0);
            }
        }

        .stats {
            display: flex;
            justify-content: space-evenly;
            background: rgba(45, 45, 45, 0.8);
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 0.9em;
            align-items: center;
            gap: 12px;
            width: 100%;
        }

        .stat-item {
            text-align: center;
            flex: 0 0 auto;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(60, 60, 60, 0.4);
            border-radius: 6px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 10px;
        }

        .stat-item:nth-child(1) {
            flex: 0 0 180px;
            min-width: 180px;
        }

        .stat-item:nth-child(2), .stat-item:nth-child(3) {
            flex: 0 0 120px;
            min-width: 120px;
        }

        .stat-number {
            font-size: 1.6em;
            font-weight: bold;
            color: #4ecdc4;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            line-height: 1.1;
        }

        .stat-label {
            color: #b0b0b0;
            font-size: 0.75em;
            margin-top: 2px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .history {
            background: rgba(45, 45, 45, 0.8);
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .history h3 {
            margin-bottom: 12px;
            color: #4ecdc4;
            font-size: 1.1em;
        }

        .history-list {
            max-height: 150px;
            overflow-y: auto;
            background: rgba(30, 30, 30, 0.8);
            border-radius: 6px;
            padding: 8px;
        }

        .history-item {
            padding: 4px 8px;
            margin: 1px 0;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.1);
            font-family: monospace;
            font-size: 12px;
        }

        .message {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 12px 20px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            max-width: 300px;
            z-index: 1000;
            animation: slideIn 0.3s ease-out;
        }

        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes slideOut {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(100%);
                opacity: 0;
            }
        }

        .message.error {
            background: rgba(255, 107, 107, 0.9);
            color: white;
            border: 1px solid rgba(255, 107, 107, 0.5);
            box-shadow: 0 4px 12px rgba(255, 107, 107, 0.3);
        }

        .message.success {
            background: rgba(78, 205, 196, 0.9);
            color: white;
            border: 1px solid rgba(78, 205, 196, 0.5);
            box-shadow: 0 4px 12px rgba(78, 205, 196, 0.3);
        }

        .error {
            background: rgba(255, 107, 107, 0.2);
            color: #ff6b6b;
            padding: 8px;
            border-radius: 6px;
            margin: 8px 0;
            border: 1px solid rgba(255, 107, 107, 0.3);
        }

        .success {
            background: rgba(78, 205, 196, 0.2);
            color: #4ecdc4;
            padding: 8px;
            border-radius: 6px;
            margin: 8px 0;
            border: 1px solid rgba(78, 205, 196, 0.3);
        }

        @media (max-width: 768px) {
            .main-controls {
                grid-template-columns: 1fr;
                gap: 15px;
            }
            
            .controls {
                flex-direction: column;
                align-items: center;
            }
            
            .random-buttons {
                flex-direction: row;
                gap: 4px;
                margin: 0;
            }
            
            .btn-random {
                flex: 1;
                min-width: 50px;
                font-size: 11px;
                padding: 5px 8px;
            }
            
            /* Stats alanını mobilde 2x2 grid yap */
            .stats {
                display: grid;
                grid-template-columns: 1fr 1fr;
                grid-template-rows: auto auto;
                gap: 12px;
                justify-items: stretch;
                align-items: stretch;
                padding: 12px;
            }
            
            .stat-item {
                width: 100%;
                min-width: auto;
                flex: none;
                padding: 8px;
                background: rgba(60, 60, 60, 0.4);
                border-radius: 6px;
                border: 1px solid rgba(255, 255, 255, 0.1);
            }
            
            .stat-item:nth-child(1) {
                grid-column: 1;
                grid-row: 1;
            }
            
            .stat-item:nth-child(2) {
                grid-column: 2;
                grid-row: 1;
            }
            
            .stat-item:nth-child(3) {
                grid-column: 1;
                grid-row: 2;
            }
            
            .stat-item:nth-child(1),
            .stat-item:nth-child(2),
            .stat-item:nth-child(3) {
                flex: none;
                min-width: auto;
                max-width: none;
            }
            
            .history-stat {
                grid-column: 2;
                grid-row: 2;
                flex: none !important;
                min-width: auto !important;
                max-width: none !important;
                width: 100% !important;
                padding: 8px;
                background: rgba(60, 60, 60, 0.4) !important;
                border-radius: 6px;
                border: 1px solid rgba(255, 255, 255, 0.1);
            }
            
            .history-stat .history-list {
                max-height: 50px;
                font-size: 0.7em;
            }
            
            .history-stat .history-item {
                font-size: 8px;
                padding: 2px 4px;
            }
        }

        .history-stat {
            flex: 0 0 130px;
            min-width: 130px;
            max-width: 130px;
            background: rgba(60, 60, 60, 0.4);
            padding: 10px;
            border-radius: 6px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            margin-left: 0;
            margin-right: 0;
        }

        .history-stat .stat-label {
            margin-bottom: 4px;
            font-size: 0.8em;
            color: #4ecdc4;
        }

        .history-stat .history-list {
            max-height: 56px;
            overflow: hidden;
            background: rgba(30, 30, 30, 0.8);
            border-radius: 4px;
            padding: 4px;
            font-size: 0.75em;
            width: 100%;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .history-stat .history-item {
            padding: 1px 4px;
            margin: 1px 0;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.1);
            font-family: monospace;
            font-size: 9px;
            text-align: center;
            line-height: 1.2;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .random-buttons {
            display: flex;
            gap: 6px;
            margin: 0;
        }

        .btn-random {
            background: linear-gradient(135deg, #3b82f6 0%, #1d4ed8 100%);
            color: white;
            padding: 6px 10px;
            border: none;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 4px;
            flex: 1;
            min-width: 60px;
            box-shadow: 0 2px 8px rgba(59, 130, 246, 0.3);
            transform: translateZ(0);
            -webkit-transform: translateZ(0);
            backface-visibility: hidden;
            -webkit-backface-visibility: hidden;
        }

        .btn-random:hover {
            transform: translateY(-1px) translateZ(0);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
            background: linear-gradient(135deg, #2563eb 0%, #1e40af 100%);
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Push Swap Visualizer</h1>
            <p>Stack A ve Stack B manipülasyonu için interaktif görselleştirici</p>
        </div>

        <div class="main-controls">
            <div class="input-section">
                <div class="input-group">
                    <label for="numbers">Sayılar:</label>
                    <textarea id="numbers" placeholder="3 2 1 4 5 (boşlukla ayırın)" rows="1"></textarea>
                </div>
                <div class="input-group">
                    <label for="steps">Sıralama Adımları:</label>
                    <textarea id="steps" placeholder="pb ra sa pa (boşluk veya yeni satırla ayırın)" rows="2"></textarea>
                </div>
            </div>
            <div class="button-section">
                <button class="btn-action" onclick="initializeStacks()">
                    <span class="icon">✓</span>
                    <span>Uygula</span>
                </button>
                <div class="random-buttons">
                    <button class="btn-random" onclick="generateRandomNumbers(100)">
                        <span class="icon">🎲</span>
                        <span>100</span>
                    </button>
                    <button class="btn-random" onclick="generateRandomNumbers(500)">
                        <span class="icon">🎲</span>
                        <span>500</span>
                    </button>
                </div>
                <button class="btn-reset" onclick="resetStacks()">
                    <span class="icon">⟲</span>
                    <span>Sıfırla</span>
                </button>
            </div>
            <div class="controls-section">
                <div class="input-group">
                    <label for="speedRange">Hız:</label>
                    <input type="range" id="speedRange" min="1" max="100" value="6" step="1" oninput="updateSpeed(this.value)">
                    <span id="speedDisplay">6ms</span>
                </div>
                <div class="control-buttons">
                    <button class="btn-small" onclick="stepBackward()">⏮</button>
                    <button class="btn-play" id="playPauseBtn" onclick="togglePlayPause()">
                        <span class="icon" id="playPauseIcon">▷</span>
                    </button>
                    <button class="btn-restart btn-small" id="restartBtn" onclick="restartPlayback()">
                        <span class="icon">⟲</span>
                    </button>
                    <button class="btn-small" onclick="stepForward()">⏭</button>
                </div>
            </div>
        </div>

        <div class="progress-bar">
            <div class="progress-info">
                <span id="progressText">Hazır</span>
                <span id="progressPercent">0%</span>
            </div>
            <div class="progress-track">
                <div class="progress-fill" id="progressFill" style="width: 0%"></div>
            </div>
        </div>

        <div class="stacks-container">
            <div class="stack-wrapper">
                <div class="stack-label">Stack A</div>
                <div class="stack empty" id="stackA">
                    <div class="empty">Stack A boş</div>
                </div>
            </div>
            <div class="stack-wrapper">
                <div class="stack-label">Stack B</div>
                <div class="stack empty" id="stackB">
                    <div class="empty">Stack B boş</div>
                </div>
            </div>
        </div>

        <div class="stats">
            <div class="stat-item">
                <div class="stat-number" id="currentStep">0</div>
                <div class="stat-label">Adımlar</div>
            </div>
            <div class="stat-item">
                <div class="stat-number" id="stackASize">0</div>
                <div class="stat-label">Stack A Boyutu</div>
            </div>
            <div class="stat-item">
                <div class="stat-number" id="stackBSize">0</div>
                <div class="stat-label">Stack B Boyutu</div>
            </div>
            <div class="stat-item history-stat">
                <div class="stat-label">Geçmiş</div>
                <div class="history-list" id="historyList">
                    <div class="history-item">~</div>
                </div>
            </div>
        </div>

    </div>

    <script>
        let stackA = [];
        let stackB = [];
        let operationCount = 0;
        let history = [];
        let isPlaying = false;
        let currentStepIndex = 0;
        let playingSteps = [];
        let playTimeout = null;
        let playSpeed = 50;
        let originalStackA = [];
        let allStates = [];

        function getElementColor(value, max, min) {
            const normalized = (value - min) / (max - min);
            const hue = (1 - normalized) * 240; // 240 (mavi) -> 0 (kırmızı)
            return `hsl(${hue}, 70%, 60%)`;
        }

        function getElementHeight(value, max, min, maxHeight = 180) {
            const normalized = (value - min) / (max - min);
            return Math.max(4, normalized * maxHeight);
        }

        function renderStacks() {
            const stackAElement = document.getElementById('stackA');
            const stackBElement = document.getElementById('stackB');
            
            // Stack A'yı render et
            if (stackA.length === 0) {
                stackAElement.innerHTML = '<div class="empty">Stack A boş</div>';
                stackAElement.classList.add('empty');
            } else {
                stackAElement.classList.remove('empty');
                const allValues = [...originalStackA];
                const max = Math.max(...allValues);
                const min = Math.min(...allValues);
                
                // Çubuk genişliğini dinamik olarak hesapla
                const containerWidth = stackAElement.clientWidth - 30; // padding çıkar
                const elementCount = stackA.length;
                const maxWidth = Math.max(1, Math.min(6, containerWidth / elementCount - 1));
                
                // Performans için chunk rendering
                const chunkSize = 200;
                let html = '';
                
                for (let i = 0; i < stackA.length; i += chunkSize) {
                    const chunk = stackA.slice(i, i + chunkSize);
                    html += chunk.map(value => {
                        const height = getElementHeight(value, max, min);
                        const color = getElementColor(value, max, min);
                        return `<div class="element" style="width: ${maxWidth}px; height: ${height}px; background-color: ${color}; transform: translateZ(0);" title="${value}"></div>`;
                    }).join('');
                }
                
                stackAElement.innerHTML = html;
            }
            
            // Stack B'yi render et
            if (stackB.length === 0) {
                stackBElement.innerHTML = '<div class="empty">Stack B boş</div>';
                stackBElement.classList.add('empty');
            } else {
                stackBElement.classList.remove('empty');
                const allValues = [...originalStackA];
                const max = Math.max(...allValues);
                const min = Math.min(...allValues);
                
                // Çubuk genişliğini dinamik olarak hesapla
                const containerWidth = stackBElement.clientWidth - 30; // padding çıkar
                const elementCount = stackB.length;
                const maxWidth = Math.max(1, Math.min(6, containerWidth / elementCount - 1));
                
                // Performans için chunk rendering
                const chunkSize = 200;
                let html = '';
                
                for (let i = 0; i < stackB.length; i += chunkSize) {
                    const chunk = stackB.slice(i, i + chunkSize);
                    html += chunk.map(value => {
                        const height = getElementHeight(value, max, min);
                        const color = getElementColor(value, max, min);
                        return `<div class="element" style="width: ${maxWidth}px; height: ${height}px; background-color: ${color}; transform: translateZ(0);" title="${value}"></div>`;
                    }).join('');
                }
                
                stackBElement.innerHTML = html;
            }
            
            updateStats();
        }

        function updateStats() {
            document.getElementById('stackASize').textContent = stackA.length;
            document.getElementById('stackBSize').textContent = stackB.length;
            document.getElementById('currentStep').textContent = `${currentStepIndex}/${playingSteps.length}`;
        }

        function updateProgress() {
            const progress = playingSteps.length > 0 ? (currentStepIndex / playingSteps.length) * 100 : 0;
            document.getElementById('progressFill').style.width = progress + '%';
            document.getElementById('progressPercent').textContent = Math.round(progress) + '%';
            
            if (isPlaying) {
                document.getElementById('progressText').textContent = `Adım ${currentStepIndex}/${playingSteps.length}`;
            } else if (currentStepIndex === playingSteps.length && playingSteps.length > 0) {
                document.getElementById('progressText').textContent = 'Tamamlandı';
            } else {
                document.getElementById('progressText').textContent = 'Hazır';
            }
        }

        function updateSpeed(value) {
            playSpeed = parseFloat(value);
            const displayValue = value == 0 ? 'MAX' : `${value}ms`;
            document.getElementById('speedDisplay').textContent = displayValue;
        }

        function addToHistory(operation) {
            history.push(operation);
            
            // Çok hızlı modda history güncellemeyi throttle et
            if (playSpeed >= 25 || history.length % Math.max(1, Math.floor(50 / Math.max(playSpeed, 0.1))) === 0) {
                const historyList = document.getElementById('historyList');
                
                // Sadece son 3 işlemi göster
                if (history.length > 3) {
                    const firstChild = historyList.firstElementChild;
                    if (firstChild) historyList.removeChild(firstChild);
                }
                
                const historyItem = document.createElement('div');
                historyItem.className = 'history-item';
                historyItem.textContent = `${history.length}. ${operation}`;
                
                if (history.length === 1) {
                    historyList.innerHTML = '';
                }
                
                historyList.appendChild(historyItem);
            }
        }

        function showMessage(message, type = 'error') {
            // Önceki mesajları temizle
            const existingMessages = document.querySelectorAll('.message');
            existingMessages.forEach(msg => msg.remove());
            
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${type}`;
            messageDiv.textContent = message;
            
            document.body.appendChild(messageDiv);
            
            setTimeout(() => {
                messageDiv.style.animation = 'slideOut 0.3s ease-out forwards';
                setTimeout(() => {
                    messageDiv.remove();
                }, 300);
            }, 3000);
        }

        async function processStepsAsync(input) {
            // Büyük veri için chunk processing
            const chunkSize = 10000;
            let result = '';
            let processed = 0;
            
            while (processed < input.length) {
                const chunk = input.substring(processed, processed + chunkSize);
                
                // Newline'ları space ile değiştir ve çoklu boşlukları temizle
                const processedChunk = chunk.replace(/\n/g, ' ').replace(/\s+/g, ' ');
                result += processedChunk;
                
                processed += chunkSize;
                
                // Büyük veri için async break - sayfa donmasını engelle
                if (processed < input.length) {
                    await new Promise(resolve => setTimeout(resolve, 0));
                }
            }
            
            return result.trim();
        }

        function parseSteps(input) {
            // Performans için optimized parsing - büyük veri için
            const steps = [];
            let current = '';
            
            for (let i = 0; i < input.length; i++) {
                const char = input[i];
                
                if (char === ' ' || char === '\t' || char === '\n' || char === '\r') {
                    if (current.length > 0) {
                        steps.push(current);
                        current = '';
                    }
                } else {
                    current += char;
                }
            }
            
            // Son adımı ekle
            if (current.length > 0) {
                steps.push(current);
            }
            
            return steps;
        }

        function parseNumbers(input) {
            // Performans için optimized parsing
            const numbers = [];
            let current = '';
            let isNegative = false;
            
            for (let i = 0; i < input.length; i++) {
                const char = input[i];
                
                if (char === '-') {
                    isNegative = true;
                } else if (char >= '0' && char <= '9') {
                    current += char;
                } else if (char === ' ' || char === '\t' || char === '\n' || char === '\r') {
                    if (current) {
                        const num = parseInt(current);
                        if (!isNaN(num)) {
                            numbers.push(isNegative ? -num : num);
                        }
                        current = '';
                        isNegative = false;
                    }
                }
            }
            
            // Son sayıyı ekle
            if (current) {
                const num = parseInt(current);
                if (!isNaN(num)) {
                    numbers.push(isNegative ? -num : num);
                }
            }
            
            return numbers;
        }

        function initializeAndPlay() {
            const numbersInput = document.getElementById('numbers').value.trim();
            const stepsInput = document.getElementById('steps').value.trim();
            
            if (!numbersInput) {
                showMessage('Lütfen sayıları girin!', 'error');
                return;
            }

            try {
                const numbers = parseNumbers(numbersInput);
                
                if (numbers.length === 0) {
                    throw new Error('Geçerli sayı bulunamadı!');
                }

                // Tekrar eden sayıları kontrol et
                const uniqueNumbers = [...new Set(numbers)];
                if (uniqueNumbers.length !== numbers.length) {
                    throw new Error('Tekrar eden sayılar olamaz!');
                }

                stackA = [...numbers];
                stackB = [];
                originalStackA = [...numbers];
                operationCount = 0;
                history = [];
                currentStepIndex = 0;
                
                document.getElementById('historyList').innerHTML = '<div class="history-item">~</div>';
                
                renderStacks();
                updateProgress();
                
                // Eğer adımlar varsa oynat
                if (stepsInput) {
                    playSteps();
                } else {
                    showMessage(`Stack A ${numbers.length} sayı ile başlatıldı!`, 'success');
                }
                
            } catch (error) {
                showMessage(error.message, 'error');
            }
        }

        async function initializeStacks() {
            const numbersInput = document.getElementById('numbers').value.trim();
            
            if (!numbersInput) {
                showMessage('Lütfen sayıları girin!', 'error');
                return;
            }

            try {
                const numbers = parseNumbers(numbersInput);
                
                if (numbers.length === 0) {
                    throw new Error('Geçerli sayı bulunamadı!');
                }

                // Tekrar eden sayıları kontrol et
                const uniqueNumbers = [...new Set(numbers)];
                if (uniqueNumbers.length !== numbers.length) {
                    throw new Error('Tekrar eden sayılar olamaz!');
                }

                stackA = [...numbers];
                stackB = [];
                originalStackA = [...numbers];
                operationCount = 0;
                history = [];
                currentStepIndex = 0;
                
                // Textarea'ları readonly yap
                document.getElementById('numbers').readOnly = true;
                document.getElementById('steps').readOnly = true;
                
                document.getElementById('historyList').innerHTML = '<div class="history-item">~</div>';
                
                renderStacks();
                updateProgress();
                
                // Sadece stackleri başlat, oynatma
                showMessage(`Stack A ${numbers.length} sayı ile başlatıldı!`, 'success');
                
                // Eğer adımlar varsa onları parse et ve hazır hale getir
                const stepsInput = document.getElementById('steps').value.trim();
                if (stepsInput) {
                    showMessage('Adımlar işleniyor...', 'success');
                    
                    // Async olarak newline'ları space ile değiştir
                    await new Promise(resolve => setTimeout(resolve, 0));
                    const cleanedSteps = await processStepsAsync(stepsInput);
                    document.getElementById('steps').value = cleanedSteps;
                    
                    const steps = parseSteps(cleanedSteps);
                    const validOperations = ['sa', 'sb', 'ss', 'pa', 'pb', 'ra', 'rb', 'rr', 'rra', 'rrb', 'rrr'];
                    
                    // Büyük veri için chunk validation
                    const chunkSize = 1000;
                    for (let i = 0; i < steps.length; i += chunkSize) {
                        const chunk = steps.slice(i, i + chunkSize);
                        for (const step of chunk) {
                            if (!validOperations.includes(step)) {
                                showMessage(`Geçersiz operasyon: ${step}`, 'error');
                                // Readonly'yi kaldır hata durumunda
                                document.getElementById('numbers').readOnly = false;
                                document.getElementById('steps').readOnly = false;
                                return;
                            }
                        }
                        // Büyük veri için async break
                        if (i > 0 && i % chunkSize === 0) {
                            await new Promise(resolve => setTimeout(resolve, 0));
                        }
                    }
                    
                    playingSteps = steps;
                    precomputeStates();
                    updateProgress();
                    showMessage(`${steps.length} adım hazır! Play butonuna basın.`, 'success');
                }
                
            } catch (error) {
                showMessage(error.message, 'error');
            }
        }

        function resetStacks() {
            stopSteps();
            stackA = [];
            stackB = [];
            originalStackA = [];
            operationCount = 0;
            history = [];
            currentStepIndex = 0;
            playingSteps = [];
            allStates = [];
            
            // UI butonlarını sıfırla
            const playBtn = document.getElementById('playPauseBtn');
            const restartBtn = document.getElementById('restartBtn');
            playBtn.classList.remove('paused');
            playBtn.removeAttribute('data-state');
            document.getElementById('playPauseIcon').textContent = '▷';
            restartBtn.classList.remove('visible');
            
            // Textarea'ları düzenlenebilir yap
            document.getElementById('numbers').readOnly = false;
            document.getElementById('steps').readOnly = false;
            
            document.getElementById('historyList').innerHTML = '<div class="history-item">~</div>';
            document.getElementById('numbers').value = '';
            document.getElementById('steps').value = '';
            
            renderStacks();
            updateProgress();
            showMessage('Tüm veriler temizlendi!', 'success');
        }

        function playSteps() {
            const stepsInput = document.getElementById('steps').value.trim();
            if (!stepsInput) {
                showMessage('Lütfen adımları girin!', 'error');
                return;
            }

            if (stackA.length === 0) {
                showMessage('Önce sayıları başlatın!', 'error');
                return;
            }

            // Adımları parse et
            const steps = parseSteps(stepsInput);
            const validOperations = ['sa', 'sb', 'ss', 'pa', 'pb', 'ra', 'rb', 'rr', 'rra', 'rrb', 'rrr'];
            
            for (const step of steps) {
                if (!validOperations.includes(step)) {
                    showMessage(`Geçersiz operasyon: ${step}`, 'error');
                    return;
                }
            }

            playingSteps = steps;
            currentStepIndex = 0;
            isPlaying = true;
            
            // Tüm durumları önceden hesapla (performans için)
            precomputeStates();
            
            executeNextStep();
        }

        function precomputeStates() {
            allStates = [];
            let tempA = [...stackA];
            let tempB = [...stackB];
            
            allStates.push({
                a: [...tempA],
                b: [...tempB]
            });
            
            // Büyük veri için chunk processing
            const chunkSize = 500;
            let processed = 0;
            
            function processChunk() {
                const endIndex = Math.min(processed + chunkSize, playingSteps.length);
                
                for (let i = processed; i < endIndex; i++) {
                    const step = playingSteps[i];
                    executeOperationOnStacks(step, tempA, tempB);
                    allStates.push({
                        a: [...tempA],
                        b: [...tempB]
                    });
                }
                
                processed = endIndex;
                
                if (processed < playingSteps.length) {
                    // Progress feedback için
                    const progress = Math.round((processed / playingSteps.length) * 100);
                    document.getElementById('progressText').textContent = `Hazırlanıyor... ${progress}%`;
                    
                    // Non-blocking processing
                    setTimeout(processChunk, 0);
                } else {
                    // Tamamlandı
                    document.getElementById('progressText').textContent = 'Hazır';
                }
            }
            
            // Büyük veri varsa chunk processing kullan
            if (playingSteps.length > 1000) {
                processChunk();
            } else {
                // Küçük veri için normal processing
                for (const step of playingSteps) {
                    executeOperationOnStacks(step, tempA, tempB);
                    allStates.push({
                        a: [...tempA],
                        b: [...tempB]
                    });
                }
            }
        }

        function executeOperationOnStacks(operation, a, b) {
            switch (operation) {
                case 'sa':
                    if (a.length >= 2) [a[0], a[1]] = [a[1], a[0]];
                    break;
                case 'sb':
                    if (b.length >= 2) [b[0], b[1]] = [b[1], b[0]];
                    break;
                case 'ss':
                    if (a.length >= 2) [a[0], a[1]] = [a[1], a[0]];
                    if (b.length >= 2) [b[0], b[1]] = [b[1], b[0]];
                    break;
                case 'pa':
                    if (b.length > 0) a.unshift(b.shift());
                    break;
                case 'pb':
                    if (a.length > 0) b.unshift(a.shift());
                    break;
                case 'ra':
                    if (a.length > 1) a.push(a.shift());
                    break;
                case 'rb':
                    if (b.length > 1) b.push(b.shift());
                    break;
                case 'rr':
                    if (a.length > 1) a.push(a.shift());
                    if (b.length > 1) b.push(b.shift());
                    break;
                case 'rra':
                    if (a.length > 1) a.unshift(a.pop());
                    break;
                case 'rrb':
                    if (b.length > 1) b.unshift(b.pop());
                    break;
                case 'rrr':
                    if (a.length > 1) a.unshift(a.pop());
                    if (b.length > 1) b.unshift(b.pop());
                    break;
            }
        }

        function executeNextStep() {
            // Akış bittiğinde kontrol et
            if (currentStepIndex >= playingSteps.length) {
                isPlaying = false;
                const playBtn = document.getElementById('playPauseBtn');
                const restartBtn = document.getElementById('restartBtn');
                playBtn.classList.remove('paused');
                
                // Akış bittiğinde play butonunu restart'a dönüştür
                document.getElementById('playPauseIcon').textContent = '⟲';
                playBtn.setAttribute('data-state', 'finished');
                restartBtn.classList.remove('visible');
                
                renderStacks();
                updateProgress();
                showMessage('Tüm adımlar tamamlandı!', 'success');
                if (isSorted() && stackB.length === 0) {
                    showMessage('Tebrikler! Stack A başarıyla sıralandı!', 'success');
                }
                return;
            }
            
            if (!isPlaying) {
                isPlaying = false;
                const playBtn = document.getElementById('playPauseBtn');
                const restartBtn = document.getElementById('restartBtn');
                playBtn.classList.remove('paused');
                
                // Normal pause durumu
                document.getElementById('playPauseIcon').textContent = '▷';
                playBtn.removeAttribute('data-state');
                restartBtn.classList.add('visible');
                
                renderStacks();
                updateProgress();
                return;
            }

            // Ultra hızlı modda batch processing (sadece 10ms altında)
            const batchSize = playSpeed < 10 ? Math.max(1, Math.floor(20 / Math.max(playSpeed, 0.1))) : 1;
            const endIndex = Math.min(currentStepIndex + batchSize, playingSteps.length);
            
            // Batch işlem
            for (let i = currentStepIndex; i < endIndex; i++) {
                const state = allStates[i + 1];
                stackA = [...state.a];
                stackB = [...state.b];
                
                const operation = playingSteps[i];
                addToHistory(operation);
                operationCount++;
                
                currentStepIndex++;
            }
            
            // Performans optimizasyonu: Çok hızlı hızlarda rendering'i throttle et
            const shouldRender = playSpeed >= 25 || currentStepIndex % Math.max(1, Math.floor(50 / Math.max(playSpeed, 0.1))) === 0;
            
            if (shouldRender || currentStepIndex >= playingSteps.length) {
                renderStacks();
                updateProgress();
            } else {
                // Sadece progress'i güncelle, render etme
                const progress = playingSteps.length > 0 ? (currentStepIndex / playingSteps.length) * 100 : 0;
                document.getElementById('progressFill').style.width = progress + '%';
                document.getElementById('progressPercent').textContent = Math.round(progress) + '%';
                document.getElementById('progressText').textContent = `Adım ${currentStepIndex}/${playingSteps.length}`;
                document.getElementById('currentStep').textContent = `${currentStepIndex}/${playingSteps.length}`;
            }

            // Sürekli kontrol
            if (currentStepIndex < playingSteps.length) {
                const actualDelay = Math.max(0.1, playSpeed);
                playTimeout = setTimeout(executeNextStep, actualDelay);
            } else {
                // Akış tamamlandığında play butonunu restart'a dönüştür
                isPlaying = false;
                const playBtn = document.getElementById('playPauseBtn');
                const restartBtn = document.getElementById('restartBtn');
                playBtn.classList.remove('paused');
                
                document.getElementById('playPauseIcon').textContent = '⟲';
                playBtn.setAttribute('data-state', 'finished');
                restartBtn.classList.remove('visible');
                
                showMessage('Tüm adımlar tamamlandı!', 'success');
                if (isSorted() && stackB.length === 0) {
                    showMessage('Tebrikler! Stack A başarıyla sıralandı!', 'success');
                }
            }
        }

        function togglePlayPause() {
            if (playingSteps.length === 0) {
                showMessage('Önce adımları uygulayın!', 'error');
                return;
            }
            
            const playBtn = document.getElementById('playPauseBtn');
            const restartBtn = document.getElementById('restartBtn');
            
            // Eğer akış bittiyse ve buton restart modundaysa
            if (playBtn.getAttribute('data-state') === 'finished') {
                restartPlayback();
                return;
            }
            
            if (isPlaying) {
                // Pause
                stopSteps();
                playBtn.classList.remove('paused');
                document.getElementById('playPauseIcon').textContent = '▷';
                restartBtn.classList.add('visible');
            } else if (currentStepIndex < playingSteps.length) {
                // Play
                isPlaying = true;
                playBtn.classList.add('paused');
                document.getElementById('playPauseIcon').textContent = '⏸';
                restartBtn.classList.remove('visible');
                playBtn.removeAttribute('data-state');
                
                // Stacks-container alanına otomatik scroll
                scrollToStacks();
                
                executeNextStep();
            } else {
                showMessage('Tüm adımlar tamamlandı!', 'success');
            }
        }

        function restartPlayback() {
            if (playingSteps.length === 0) {
                showMessage('Önce adımları uygulayın!', 'error');
                return;
            }
            
            // Baştan başla
            currentStepIndex = 0;
            const state = allStates[currentStepIndex];
            stackA = [...state.a];
            stackB = [...state.b];
            operationCount = 0;
            history = [];
            document.getElementById('historyList').innerHTML = '<div class="history-item">~</div>';
            renderStacks();
            updateProgress();
            
            // Restart butonunu gizle
            const restartBtn = document.getElementById('restartBtn');
            restartBtn.classList.remove('visible');
            
            // Play butonunu başlangıç durumuna getir
            const playBtn = document.getElementById('playPauseBtn');
            playBtn.classList.remove('paused');
            playBtn.removeAttribute('data-state');
            document.getElementById('playPauseIcon').textContent = '▷';
            
            showMessage('Oynatma baştan başlatıldı!', 'success');
        }

        function startPlaying() {
            if (playingSteps.length === 0) {
                showMessage('Önce adımları uygulayın!', 'error');
                return;
            }
            
            const playBtn = document.getElementById('playPauseBtn');
            const restartBtn = document.getElementById('restartBtn');
            
            if (currentStepIndex >= playingSteps.length) {
                // Baştan başla
                restartPlayback();
                return;
            }
            
            isPlaying = true;
            playBtn.classList.add('paused');
            document.getElementById('playPauseIcon').textContent = '⏸';
            restartBtn.classList.remove('visible');
            
            // Stacks-container alanına otomatik scroll
            scrollToStacks();
            
            executeNextStep();
        }

        function stepForward() {
            if (playingSteps.length === 0) {
                showMessage('Önce adımları uygulayın!', 'error');
                return;
            }
            
            if (currentStepIndex < playingSteps.length && allStates.length > 0) {
                const state = allStates[currentStepIndex + 1];
                stackA = [...state.a];
                stackB = [...state.b];
                
                const operation = playingSteps[currentStepIndex];
                addToHistory(operation);
                operationCount++;
                
                currentStepIndex++;
                renderStacks();
                updateProgress();
                
                // Akış bittiğinde buton durumunu güncelle
                if (currentStepIndex >= playingSteps.length) {
                    const playBtn = document.getElementById('playPauseBtn');
                    const restartBtn = document.getElementById('restartBtn');
                    
                    document.getElementById('playPauseIcon').textContent = '⟲';
                    playBtn.setAttribute('data-state', 'finished');
                    restartBtn.classList.remove('visible');
                    
                    showMessage('Tüm adımlar tamamlandı!', 'success');
                    if (isSorted() && stackB.length === 0) {
                        showMessage('Tebrikler! Stack A başarıyla sıralandı!', 'success');
                    }
                }
            }
        }

        function stepBackward() {
            if (playingSteps.length === 0) {
                showMessage('Önce adımları uygulayın!', 'error');
                return;
            }
            
            if (currentStepIndex > 0 && allStates.length > 0) {
                currentStepIndex--;
                const state = allStates[currentStepIndex];
                stackA = [...state.a];
                stackB = [...state.b];
                
                renderStacks();
                updateProgress();
                
                // Geri dönerken restart durumunu temizle
                const playBtn = document.getElementById('playPauseBtn');
                const restartBtn = document.getElementById('restartBtn');
                
                if (playBtn.getAttribute('data-state') === 'finished') {
                    document.getElementById('playPauseIcon').textContent = '▷';
                    playBtn.removeAttribute('data-state');
                    restartBtn.classList.add('visible');
                }
            }
        }

        function stopSteps() {
            isPlaying = false;
            const playBtn = document.getElementById('playPauseBtn');
            playBtn.classList.remove('paused');
            document.getElementById('playPauseIcon').textContent = '▷';
            if (playTimeout) {
                clearTimeout(playTimeout);
                playTimeout = null;
            }
            updateProgress();
        }

        function scrollToStacks() {
            const stacksContainer = document.querySelector('.stacks-container');
            if (stacksContainer) {
                stacksContainer.scrollIntoView({
                    behavior: 'smooth',
                    block: 'start'
                });
            }
        }

        function isSorted() {
            for (let i = 1; i < stackA.length; i++) {
                if (stackA[i] < stackA[i-1]) {
                    return false;
                }
            }
            return true;
        }

        // Enter tuşu için olay dinleyicisi
        document.getElementById('numbers').addEventListener('keypress', function(e) {
            if (e.key === 'Enter' && e.ctrlKey) {
                initializeStacks();
            }
        });

        document.getElementById('steps').addEventListener('keypress', function(e) {
            if (e.key === 'Enter' && e.ctrlKey) {
                initializeStacks();
            }
        });

        // Pencere yüklendiğinde varsayılan değerlerle başlat
        window.onload = function() {
            // Varsayılan değerler
            document.getElementById('numbers').value = '';
            initializeStacks();
        };

        // Pencere yeniden boyutlandırıldığında element boyutlarını güncelle
        window.addEventListener('resize', function() {
            if (stackA.length > 0 || stackB.length > 0) {
                renderStacks();
            }
        });

        function generateRandomNumbers(count) {
            // Eğer textarea readonly ise işlem yapma
            if (document.getElementById('numbers').readOnly) {
                showMessage('Önce sıfırla butonuna basın!', 'error');
                return;
            }
            
            try {
                // Benzersiz sayılar oluştur
                const numbers = [];
                const usedNumbers = new Set();
                
                // Sayı aralığını belirle (count'un 2 katı kadar geniş aralık)
                const range = Math.max(count * 2, 1000);
                const minValue = -Math.floor(range / 2);
                const maxValue = Math.floor(range / 2);
                
                // Benzersiz sayıları oluştur
                while (numbers.length < count) {
                    const randomNum = Math.floor(Math.random() * (maxValue - minValue + 1)) + minValue;
                    
                    if (!usedNumbers.has(randomNum)) {
                        usedNumbers.add(randomNum);
                        numbers.push(randomNum);
                    }
                }
                
                // Sayıları textarea'ya yaz
                document.getElementById('numbers').value = numbers.join(' ');
                
                // Mevcut steps'i temizle
                document.getElementById('steps').value = '';
                
                // Başarı mesajı
                showMessage(`${count} benzersiz rastgele sayı oluşturuldu!`, 'success');
                
            } catch (error) {
                showMessage('Rastgele sayılar oluşturulurken hata oluştu!', 'error');
            }
        }

        async function processStepsAsync(input) {
            // Büyük veri için chunk processing
            const chunkSize = 10000;
            let result = '';
            let processed = 0;
            
            while (processed < input.length) {
                const chunk = input.substring(processed, processed + chunkSize);
                
                // Newline'ları space ile değiştir ve çoklu boşlukları temizle
                const processedChunk = chunk.replace(/\n/g, ' ').replace(/\s+/g, ' ');
                result += processedChunk;
                
                processed += chunkSize;
                
                // Büyük veri için async break - sayfa donmasını engelle
                if (processed < input.length) {
                    await new Promise(resolve => setTimeout(resolve, 0));
                }
            }
            
            return result.trim();
        }


    </script>
</body>
</html>
